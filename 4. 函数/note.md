# 学习笔记

## 4.1 简介

* Rust函数用关键字fn开头，可以有一系列参数和一个返回类型
* 函数体包含一系列语句（或表达式）
* 函数返回可以使用return语句，也可以使用表达式。函数不写返回类型的情况下，编译器默认返回类型是unit()，此处和表达式的规定是一致的
* 函数的参数列表与let语句一样，是一个“模式解构”
* 函数可以当成头等公民（first class value）被复制到一个值中，这个值可以像函数一样被调用
* Rust中，每个函数都具有自己单独的类型，但是这个类型可以自动转换到fn类型，但是不能在参数和返回值类型不同的情况下作类型转换。就像把函数签名当做可以被其他函数类型的通用类型，但是函数签名不同则属于不是同一个通用类型
* Rust函数体内也允许定义其他item，包括：静态变量、常量、函数、trait、类型、模块等。当需要一些item仅在此

## 4.2 发散函数

* Rust支持一种特殊类型的发散函数（Diverging functions），它的返回类型是感叹号！。如果一个函数根本不能正常返回：
  * panic!以及基于它实现的各种函数/宏，比如unimplemented!、unreachable!
  * 死循环loop{}
  * 进程退出函数std::process::exit以及类似的libc中的exec一类函数
* 发散类型的最大特点是：它可以被转换为任意一个类型

```rust
fn diverges() ->! {
    panic!("This function never returns!");
}
```

## 4.3 main函数

* Rust的main函数接收参数设计与C等语言不同，传递参数和返回状态码都由单独的API来完成。Rust的main函数只支持无参数、无返回值的声明方式，即main函数的签名固定为：` fn main() -> () `
* std::env::args()返回的参数中，每个命令行中被空格分开的字符串都是一个参数。
* 进程任何时候都可以调动std::process::exit()直接退出，退出时候的错误码由exit()函数的参数指定
* 读取环境变量：
  * std::env::var()，接受一个字符串类型参数，用于查找当前环境变量中是否存在这个名字的环境变量
  * std::env::vars()，不携带参数，可以返回所有的环境变量
* 为了解决?符号作为错误处理语法糖要求函数返回的是Result类型的问题，Rust设计组扩展了main函数的签名，使它变成了一个泛型函数，这个函数的返回类型可以是任何一个满足Terminationtrait约束的类型，其中()、bool、Result都是满足这个约束的

## 4.4 const fn

* 函数可以用const关键字修饰，这样的函数可以在编译阶段被编译器执行，返回值也被视为编译期常量
* const函数是在编译阶段执行的，因此相比普通函数有许多限制，并 非所有的表达式和语句都可以在其中使用

## 4.5 函数递归调用

* Rust允许函数递归调用。所谓递归调用，指的是函数直接或者间接
调用自己