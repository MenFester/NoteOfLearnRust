# 学习笔记

## 什么是所有权

* 正是所有权概念和相关工具的引入，Rust才能够在没有垃圾回收机制的前提下保障内存安全
* 某些编程语言会在运行时定期检查并回收那些没有被继续使用的内存。另外一些语言，程序员需要手动地分配和释放内存。Rust采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何运行时开销
* 理解所有权概念可以帮助理解Rust中其余那些独有的特性，它会为接下来学习打下坚实的基础。消化所有权概念，就可以基于Rust和所有权系统越来越自然地编写出安全且高效的代码
* 堆与栈：
  * 栈：
    * “后进先出”
    * 存储在栈中的数据都必须拥有一个已知固定的大小，编译期无法确定大小的数据只能存储在堆中
    * 将值压入栈中不叫分配
  * 堆：
    * 希望将数据放入堆中时，操作系统会根据你的请求在堆中找到一块足够可用空间，将它标记为已使用，并把指向这片空间地址的指针返回给我们。这一过程叫做堆分配
    * 由于多了指针跳转的环节，所以访问在堆上的数据要慢于访问栈上的数据
    * 许多系统编程语言都需要你记录代码中分配的堆空间，最小化堆上的冗余数据，并及时清理堆上无用数据以避免耗尽空间。一旦熟练掌握所有权及相关工具，就可以将这些问题交个Rust处理，减轻用于思考栈和堆的心智负担。
* 所有权规则：
  * Rust中的每一个值都有一个对应的变量作为它的所有者
  * 在同一时间内，值有且仅有一个所有者
  * 当所有者离开自己的作用域时，它持有的值就会被释放掉
* 变量的作用域：作用域时变量在程序中有效的范围
* String类型：
  * 字符串字面量被硬编码进程序
  * String类型会在堆上分配自己需要的存储空间，所以它可以处理在编译时未知大小的文本
  * String是可变的，而字符串字面量不是，这是因为它们采用了不同的内存处理方式
* 内存与分配：
  * 类似字符串字面量，得益于不可变性及在编译时就知道内容，是被直接嵌入到可执行文件中的
  * 为了支持一个可变的、可增长的类型，需要在堆上分配一块在编译时未知大小的内存来存放数据
    * 内存是由操作系统在运行时动态分配的
    * 当使用完需要通过某种方式将这些内存归还给操作系统
  * 大部分编程语言都有类似的设计：由程序员来发起堆内存的分配请求
  * 拥有垃圾回收（Garbage Collection，GC）机制的语言中，GC会代替程序员来负责记录并清除那些不再使用的内存
  * Rust提供另一套解决方案：内存会自动地在拥有它的变量离开作用域后进行释放。Rust在变量离开作用域时，会调用一个叫做drop的特殊函数。类型的作者可以在这个函数中编写释放内存的代码
  * 变量和数据的交互方式：移动。对于在堆中分配内存的值，用一个变量向另一个变量赋值，实际发生了浅度拷贝（shallow copy），例如String类型的浅度拷贝是拷贝了变量的指针、长度及容量字段。由于Rust在这种拷贝发生时，同时使第一个变量无效了，所以我们用术语“移动（move）”来描述这一行为
  * Rust永远不会自动地创建数据的深度拷贝，这是另一个设计原则
  * 变量和数据的交互方式：克隆。当你确实需要去深度拷贝堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法（这里是针对String类型而言）
  * 栈上的数据：复制。类似于整型等可以在编译时确定自己大小，并且能够将自己的数据完整地存储在栈中，这些值的复制操作永远是非常快的。对于这些类型而言，深度拷贝与浅度拷贝没有任何区别，调用clone不会与直接的浅度拷贝有任何行为上的区别
* Rust提供了一个名为Copy的trait，它可以用于完全存储在栈上的数据类型。
  * 一旦某类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性
  * 如果一种类型本身或这种类型的任意成员实现Drop这种trait，那么Rust就不允许其实现Copy这种trait
  * 尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait，会导致编译错误
  * 一些拥有Copy这种trait的类型：
    * 所有整数类型
    * 仅拥有两种值的布尔类型
    * 字符类型
    * 所有的浮点类型
    * 如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的
* 将值传递给函数在语义上类似于对变量进行赋值：将变量传递给函数将会触发移动或复制，就像赋值语句一样
* 总之，移动或复制，其实都是“按值拷贝”。分配在栈上的按值拷贝了本身全部，分配在堆上的只是按值拷贝了绑定的解构，且由于所有权机制原绑定不再持有变量
* 函数在返回值的过程中也会发生所有权的转移。
* 变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上

## 引用与借用

* &代表引用语义，它们允许你在不获取所有权的前提下使用值。&s结构中的指针指向s，s结构中的指针才最终指向堆内存中的值
* 与使用&进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符
* 通过引用传递参数给函数的方法也被称为借用（borrowing）
* 用&mut修饰的是可变引用（mutable borrow)
* 可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据，一次只能声明一个可变引用。这条规则可以帮助我们在编译时避免数据竞争
* 与大部分语言类似，我们可以通过花括号来创建一个新的作用域范围。这就使我们可以创建多个可变引用，当然，这些可变引用不会同时存在
* 数据竞争与竞态条件十分类似，它会在指令满足以下3种情形时发生：
  * 两个或两个以上的指针同时访问同一空间
  * 其中至少有一个指针会向空间中写数据
  * 没有同步数据访问的机制
* 以下两个规则看代码的实际演示，主要看声明引用后有无立即被使用。通常延迟使用的会造成报错：
  * 同时存在多个不可变引用时合理合法的，对数据的只读操作不会影响到其他读取数据的用户
  * 不能在拥有不可变引用的同时创建可变引用，不可变引用的用户不希望眼皮底下的值突然发生变化
* 悬垂指针：这类指针指向曾经存在的某内存地址，但该内存已经被释放掉甚至是被重新分配另作他用

## 切片

* 除了引用，Rust还有另外一种不持有所有权的数据类型：切片（slice）。切片允许我们引用集合中某一段连续的元素序列，而不是整个集合
* as_bytes方法将String类型变量转换为字节数组
* iter方法创建了一个可以遍历的迭代器
* 我们可以在一对方括号中指定切片的范围区间` [starting_index..ending_index] `
* 切片数据结构在内部存储了指向起始位置的引用和一个描述切片长度的字段。这个描述切片长度的字段等价于ending_index减去starting_index
* Rust的范围语法` .. `有一个语法糖：当你希望范围从第一个元素（索引值为0的元素）开始时，可以省略两个点号之前的值；当你的切片想要包含最后一个值，也可以省略双点号之后的值；同时省略前值、后值，来创建一个指向全体元素的切片
* 字符串切片的边界必须位于有效的UTF-8字符边界内。尝试从一个多字节字符的中间位置创建字符串切片会导致运行时错误
* 字符串字面量被直接存储在了二进制程序中，` let s = "Hello, world!"; `这里变量s的类型其实就是&str：它是一个指向二进制程序特定位置的切片。正是由于&str是一个不可变引用，所以字符串字面量自然是不可变的。字符串字面量就是切片
* 在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能：` fn first_word(s: &str) -> &str { ... } `
* Rust还有其他更加通用的切片类型。例如：` let a = [1, 2, 3, 4, 5]; let slice = &a[1..3]; `，这里切片类型是` &[i32] `