# 学习笔记

## 前言

* Rust标准库包含了一系列非常有用的被称为集合的数据结构。大部分数据结构都代表特定的值，但集合可以包含多个值
* 与内置的数组和元组类型不同，集合将自己持有的数据存储在堆上，这意味着数据的大小不需要在编译时确定，并且可以随程序的运行按需扩大或缩小数据占用的空间
* 不同的集合类型有着不同的性能与开销，需要学会如何为特定的场景选择合适的集合类型

## 使用动态数组存储多个值

* 动态数组：` Vec<T> `。动态数组允许在单个数据结构中存储多个相同类型的值，这些值会彼此相邻地排布在内存中
* 调用函数Vec::new来创建一个空动态数组，也可以使用vec!宏根据提供的初始化值来创建一个新的动态数组
* 动态数组添加元素：push方法
* 和其他的struct一样，动态数组一旦离开作用域就会被立即销毁，动态数组中的所有内容都会随着动态数组的销毁而销毁
* 读取动态数组中的元素：
  * 使用索引（索引值从0开始），越界访问时触发panic
  * 使用get方法（接收索引作为参数，返回` Option<T> `)，所以使用get越界访问时返回None
* 一旦程序获得了一个有效的引用，借用检查器就会执行所有权规则和借用规则，来保证这个引用及其他任何指向这个动态数组的引用始终有效。同时存在动态数组不可变引用和可变引用，且都使用了这些引用时就会报错。原理：动态数组中的元素是连续存储的，插入新的元素后也许会没有足够多的空间将所有元素依次相邻放下，这就需要分配新的内存空间，并将旧元素移动到新的空间上。所以不可变引用可能会因为插入行为而指向被释放的内存，而借用规则帮助我们规避这类问题
* 遍历动态数组中的值：使用for...in...循环
* 当需要在动态数组中存储不同类型的元素时，可以定义并使用枚举来应对这种情况，因为枚举中所有变体都被定义为了同一种枚举类型
* 为了计算出元素在堆上使用的存储空间，Rust需要在编译时确定动态数组的类型
* 一定要了解标准库中关于` Vec<T> `的API文档

## 使用字符串存储UTF-8编码的文本

* 字符串是一个超乎许多编程者想象的复杂数据结构
* Rust字符串使用了UTF-8编码
* 字符串本身是基于字节的集合，并通过功能性的方法将字节解析为文本
* Rust语言核心部分只有一种字符串类型，那就是字符串切片str，它通常以借用的形式（&str）出现。字符串切片是一些指向存储在别处的（例如：字符串字面量的数据存储在程序的二进制文件中，而它们本身也是字符串切片的一种）UTF-8编码字符串的引用
* String类型定义在Rust标准库中而没有内置在语言的核心部分，String和&str两种类型都广泛地被应用于Rust标准库中且都采用了UTF-8编码
* Rust标准库中包含了其他一系列的字符串类型：OsString、OsStr、CString、CStr，这些命名的结尾以String或Str表明类型提供的是所有者版本还是借用者版本
* 许多对于` Vec<T> `可用的操作也同样可用于String。
  * 调用String::new来创建一个新的空字符串
  * 对于实现了Display trait的类型调用to_string方法（这个方法可以直接作用于字符串字面量）
  * 使用函数String::from来基于字符串字面量生成String
  * 使用push_str或push向字符串中添加内容
  * 使用+运算符或format!宏（拼接多个字符串时）来拼接字符串，编译器可以自动将&String类型的参数强制转换为&str类型，将&s转换为` &s[..] `
* Rust中的字符串不支持索引。String实际上是一个基于` Vec<u8> `的封装类型，而存储一个UTF-8的码值可能占用不一样字节数，所以索引有得到意外值的风险。字符串索引操作应当返回的类型是不明确的：究竟应该是字节、还是字符或是字型簇
* Rust中提供了不同的方式来解析存储在计算机中的字符串数据，以便程序员自行选择所需的解释方式，而不用关心具体的语言类型
* 为了明确表明需要一个字符串切片，需要在索引的`[ ]`中填写范围来指定所需的字节内容。要小心谨慎地使用范围语法创建字符串切片，因为错误指令会导致程序崩溃
* 遍历字符串方法：
  * chars方法，返回Unicode的标量值。合法的标量值可能会需要占用1字节以上的空间
  * bytes方法，依次返回每个原始字节
  * 从字符串中获取字型簇相对复杂，标准库中没有提供这个功能，可以在crates.io上获取相关的开源库
* Rust选择了将正确的String数据处理方法作为所有Rust程序的默认行为，意味着程序员需要提前理解UTF-8数据的处理流程

## 在哈希映射中存储键值对

* 哈希映射：` HashMap<K, V> `，存储了从K类型键到V类型值之间的映射。哈希映射在内部实现中使用了哈希函数
* 引如：` use std::collections::HashMap `
* 创建新的哈希映射：`HashMap::new()`
* 和动态数组一样，哈希映射也将其数据存储在堆上
* 和动态数组一样，哈希映射也是同质的：它要求所有的键必须拥有相同的类型，所有的值也必须拥有相同的类型
* 另一个构建哈希映射的方法：在一个由键值对组成的元组动态数组上使用collect方法。这里的collect方法可以将数据收集到很多数据结构中，这些数据结构也包括HaspMap。使用collect方法，应该使用` HashMap<_, _> `，因为collect可以用于许多不同的数据结构
* zip方法，将在两个不同动态数组中的数据逐项对应组合起来，创建一个元组的数组
* 对于那些实现了Copy trait的类型（例如i32)，它们的值会被简单地复制到哈希映射中。而对于String这种持有所有权的值，其值将会转移且所有权会移给哈希映射
* get方法，通过将键传入来获得哈希映射中的值。get返回的是` Option<&V> `
* 类似动态数组，可以使用for循环来遍历哈希映射
* 覆盖旧值：例如连续执行两次insert，但使用同样的键
* 只在键没有对应值时插入数据：哈希映射中提供了一个被entry的专用API来处理，它接收我们想要检测的键作为参数，并返回一个叫做Entry的枚举作为结果。这个枚举指明了键所对应的值是否存在
* Entry的or_insert方法被定义为返回一个Entry键所指向值的可变引用，假如这个值不存在，就将参数作为新值插入哈希映射中，并把这个新值的可变引用返回
* 基于旧值来更新值：使用上述返回的可变引用来更新映射的值
