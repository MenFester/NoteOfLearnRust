# 学习笔记

## 定义枚举

* 枚举类型（简称枚举），它允许我们列举所有可能的值来定义一个类型
* 枚举的变体全都位于其标识符的命名空间中，并使用两个冒号来将标识符和变体分隔开来
* 以枚举类型为参数类型的函数，可以使用任意一个变体来调用这个函数
* 枚举允许我们直接将其关联的数据嵌入枚举变体内，这就无须另外使用结构体将枚举和数据关联
* 另外一个使用枚举代替结构体的优势在于：每个变体可以分别拥有不同类型和数量的关联数据
* 可以在枚举的变体中嵌入任意类型的数据，包括：字符串、数值、结构体、另一个枚举
* 假如我们使用不同的结构体，每个结构体都会拥有自己的类型，我们无法轻易定义一个能够统一处理这些类型数据的函数。如果使用枚举，看做将各种结构体定义在一个枚举中，其中结构体的名称为变体值、结构体的定义可以为一般或者元组结构体定义
* 枚举和结构体还有一点相似的：可以使用impl关键字定义枚举的方法
* Option类型描述了一种值可能不存在的情况，所以它被广泛地应用在各种地方。空值的问题在于，当你尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。Rust中虽然没有空值，但却提供了一个拥有类似概念的枚举，可以用来标识一个值无效或缺失。这个枚举就是` Option<T> `。` <T> `意味着Option枚举中的Some变体可以包含任意类的数据（泛型）
* ` Option<T> `枚举非常常见且很有用，所以它被包含在了预导入模块中。这意味着不需要显示地将它和它的变体引入作用域，可以直接使用变体Some或None
* 如果使用了None而不是Some变体来赋值，需要明确地告知Rust这个` Option<T> `的具体类型
* 只有当我们持有的类型是` Option<T> `时，我们必须考虑值不存在的情况（其他类型编译器确保我们所持有的值是有效的），编译器会迫使我们在使用值之前正确地做出处理操作。
* ` Option<T> `设计比“空值”设计好，是因为` Option<T> `和` T `是不同类型，编译器不会允许我们像使用普通值一样去直接使用` Option<T> `的值
* 为了持有一个可能为空的值，我们总是需要将它显式地放入对应类型的` Option<T> `值中。当我们随后使用这个值的时候，也必须显式地处理它可能为空的情况
* ` Option<T> `枚举针对不同的使用场景提供了大量的实用方法，熟练掌握将提供巨大帮助。为了使用一个` Option<T> `值，必须编写处理每个变体的代码。某些代码只会在持有Some(T)值是运行，它们可以使用变体中存储的T。而另一些代码只会在持有None值时运行，这些代码将没有可用的T值

## 控制流运算符match

* match，它允许将一个值与一系列的模式相比较，并根据匹配的模式（模式可由字面量、变量名、通配符和许多其他东西组成）执行相应代码
* match的能力不仅来自模式丰富的表达能力，也来自编译器的安全检查，它确保了所有可能的情况都会得到处理
* 可以将match表达式想象成一台硬币分类机，值会依次通过match中的模式，并且在遇到第一个“符合”的模式时进入相关联的代码块，并在执行过程中被代码所使用
* match关键字后面会跟随一个表达式，与if表达式十分相似。但if语句中表达式需要返回一个布尔值，而match后的表达式可以返回任何类型
* match分支：由模式和它所关联的代码组成，` => `用于将模式和代码区分开来
* match表达式执行时，将产生的结果值依次与每个分支中的模式相比较。匹配成功则与该模式关联的代码会被继续执行。匹配失败，则会继续执行下一个分支
* 分支可以有任意多个，每个分支所关联的代码同时也是一个表达式，这个表达式结果值被作为整个match表达式结果返回
* 如果分支代码足够短，通常不需要使用花括号。分支中包含多行代码，可以使用花括号
* 匹配分支可以绑定被匹配对象的部分值，这正是我们用于从枚举变体中提取值的方法。可以用这种方法从` Option<T> `中的Some变体中提取值
* Rust代码中许多类似套路：使用match来匹配枚举值，并将其中的值绑定到某个变量上，接着根据这个值执行相应代码
* Rust知道我们没有覆盖所有可能的情形，甚至能够确切地指出究竟是哪些模式被我们漏掉了。Rust中的匹配是穷尽的（exhausitive）：我们必须穷尽所有的可能性，来确保代码是合法有效的
* 有的时候我们并不想要处理所有可能的值，可以通过一个特殊模式“_”来替代其余的值（匹配任何值）

## 简单控制流if let

* 某些情况下，match仍然会显得有些繁琐，为此Rust提供了if let语句
* if let能让我们通过一种不那么繁琐的语法结合使用if和let，并处理那些只用关系某一种匹配而忽略其他匹配的情况
* if let语法使用一对以=隔开的模式与表达式
* 使用if let意味着你可以编写更少的代码，使用更少的缩进，使用更少的模板代码。但是，也放弃了match所附带的穷尽性检查
* 可以将if let视作match的语法糖，它只在值满足某一特定模式时运行代码，而忽略其他所有的可能性
* 我们还可以在if let中搭配使用else。else所关联的代码块在if let语句中扮演的角色，就如同match中_模式所关联的代码块一样