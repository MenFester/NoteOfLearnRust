# 学习笔记

## 变量与可变性

* Rust中变量默认是不可变的，这一特性是为了能够安全且方便地写出复杂、甚至是并行的代码
* 当一个变量是不可变的时候，一旦它被绑定到某个值上面，这个值就再也无法被改变
* Rust编译器能够保证那些声明为不可变的值一定不会发生改变。这也意味着你无须在阅读和编写代码时追踪一个变量会如何变化，从而使代码逻辑更加易于理解和推导
* 可以通过在声明的变量名称前添加mut关键字来使其可变
* 设计一个变量的可变性还需要考虑很多因素
  * 使用某些重型数据结构时，是当地使用可变性去修改一个实例，比赋值和重新返回一个新分配的实例要更加有效率
  * 当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解
* 变量与常量的不同：
  * 不能用mut关键字来修饰一个常量
  * 使用const关键字而不是let关键字声明一个常量
  * 常量声明时总是需要标注类型
  * 常量可以被声明在任何作用域中，甚至包括全局作用域。这在一个值需要被不同部分的代码共同引用时十分有用
  * 你只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值或者其他需要在运行时计算的值绑定在常量上
  * Rust中，约定使用下划线分隔的全大写字母来命名一个常量
* 可以重复使用let关键字并配以相同的名称来不断地隐藏（shadow）变量
* 重复使用let关键字会创建出新的变量，所以我们可以在重复变量名称的同时改变它的类型

## 数据类型

* Rust中的每个值都有其特定的数据类型，Rust会根据数据的类型来决定应该如何处理它们
* Rust是静态类型语言，在编译的过程中需要知道所有变量的类型
* 大部分情况下，编译器可以根据我们如何绑定、使用变量的值来自动推导出变量的类型
* 两种不同的数据类型子集：标量类型（scalar）和复合类型（compound）
* 标量类型，是单个值类型的统称
  * 整数
    * 有符号：i8、i16、i32、i64、isize
    * 无符号：u8、u16、u32、u64、usize
    * isize和usize长度取决于程序运行的目标平台
    * 书写整数字面量
      * Decimal：98_222
      * Hex：0xff
      * Octal：0o77
      * Binary：0b1111_0000
      * Byte(u8 only)：b'A'
    * 拿不定使用哪种整数类型，Rust整数字面量的默认推导类型i32是一个很好的选择，它在大部分情形下都是运算速度最快的
    * 整数溢出时：
      * debug模式下编译时触发panic（Rust使用panic来描述程序因为错误而退出的情形）
      * 编译时使用了--release标记的发布（release）模式，Rust会在溢出发生时执行二进制补码环绕（任何超出类型最大值的数值都会被“环绕”为类型最小值）。例如：u8类型的257会变为1
      * 假如确实希望显式地进行环绕行为，可以使用标准库中的类型Wrapping
  * 浮点数
    * f32，单精度浮点数
    * f64，双精度浮点数。Rust默认将浮点数字面量推导为f64类型（现代CPU中f32与f64运行效率相差无几）
    * 浮点数使用了IEEE-754标准来进行表述
  * 常见数值运算：
    * +，加
    * -，减
    * *，乘
    * /，除
    * %，求余
  * 布尔值
    * 使用bool表示布尔类型
    * 布尔类型只有两个可能的值：true、false
    * 布尔类型占据占据单字节的空间大小
    * 布尔类型主要用途是在if表达式内作为条件使用
  * 字符
    * char类型用于描述语言中最基础的单个字符
    * char类型使用单引号指定，不同于字符串使用双引号指定
    * Rust中char类型占4个字节，是一个Unicode标量值
* 复合类型：
  * 复合类型（compound type)可以将多个不同类型的值组合为一个类型
  * Rust提供了两种内置的基础复合类型：元组（tuple）和数组（array）
  * 元组类型：
    * 可以将其他不同类型的多个值组合进一个复合类型中
    * 元组有固定长度，无法在声明结束后增加或减少其中的元素数量
    * 创建元组，需要把一系列的值用逗号分隔后放置到一对圆括号中
    * 元组的每个位置的值都有一个类型，这些类型不需要是相同的
    * 可以使用模式匹配类结构元组
    * 除了解构，还可以通过索引并通过点号(.)来访问元组中的值
  * 数组类型：
    * 数组的每个元素必须是相同类型，由一整块分配在栈上的内存组成
    * 数组有固定长度，一旦声明就再也不能随意更改大小
    * 创建数组，将以逗号分隔的值放置在一对方括号内
    * 使用场景：
      * 想在栈上而不是堆上分配空间时
      * 想要确保总有固定数量的元素时
    * Rust标准库提供了灵活的动态数组（vector）类型，是一种类似于数组的集合结构，允许用户自由地调整数组长度
    * 声明数组类型、长度语法：声明数组变量类型时，使用方括号中填写数组内所有元素类型、一个分号、数组内元素数量
    * 初始化数组语法：给变量赋值时，使用方括号中填写指定元素的值、一个分号、数组长度
    * 通过索引并通过方括号([])来访问数组
    * Rust中越界访问数组，编译时不报错，但是运行时产生panic。每次通过索引访问一个元素时，Rust都会检查这个索引是否小于当前数组的长度

## 函数

* fn关键字用来声明一个新的函数
* Rust代码使用蛇形命名法来作为规范函数和变量名称的风格。蛇形命名法只使用小写的字母进行命名，并以下划线分隔单词
* Rust不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可
* 可以在函数中定义参数（parameters），它们是一种特殊的变量，并被视作函数签名的一部分
* 当函数存在参数时，你需要在调用函数时为这些变量提供具体的值
* 在函数签名中，你必须显示地声明每个参数的类型，编译器器无需通过其他部分的代码进行推导就能明确地知道你的意图
* 通过逗号分隔符可为函数声明多个参数，参数可以是不同类型
* 函数体由若干条语句组成，并可以以一个表达式作为结尾
* Rust是一门基于表达式的语言，它将语句与表达式区别为两个不同的概念
  * 语句：执行操作但不返回值的指令
  * 表达式：会进行计算并产生一个值作为结果的指令
  * 表达式本身也可以作为语句的一部分
  * 调用函数是表达式
  * 调用宏是表达式
  * 代码块输出的值就是其中最后一个表达式的值
  * 数字本身可以作为一个表达式使用
* 函数定义时，在箭头符号（->）的后面声明返回值的类型，但不用为返回值命名
* 在Rust中，函数的返回值等同于函数体最后一个表达式的值，也可以用return关键字并指定一个值来提前从函数中返回
* 如果函数没有明确通过表达式或return返回值，Rust默认返回了一个空元组

## 注释

* 在Rust中，注释必须使用两道斜杠开始，并持续到本行结尾
  
## 控制流

* if表达式：
  * 使用if关键字开头，紧跟一个判断条件表达式。
  * 条件表达式必须产生一个bool类型的值，否则会触发编译错误。Rust不会尝试将非布尔类型的值转换为布尔类型
  * if表达式中与条件相关联的代码块被称作分支（arm）
  * if表达式有可选的else表达式
  * 可以组合if、else、else if表达式来实现多重条件判断
  * 过多的else if表达式会使我们的代码变得杂乱无章，Rust中另一个强大的分支结构语法match可以用来应付这种情况
  * 由于if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值
  * 所有if分支可能返回的值都必须是另一种类型的，假如不同的分支表达式产生的类型无法匹配，那么会触发编译错误
* Rust提供了3种循环：loop、while、for
  * loop：指示Rust反复执行某一块代码
  * 可以将需要返回的值添加到break表达式后面，可以在代码中使用这个从循环中返回的值
  * while：每次执行循环体之前都判断一次条件，假如条件为真则执行代码片段，假如条件为假或在执行过程中碰到break就退出循环
  * for：安全性和简捷性使for称为Rust最为常用的循环结构
  * 为了实现循环特定次数的任务，也可以用for配合标准库中提供的Range来实现