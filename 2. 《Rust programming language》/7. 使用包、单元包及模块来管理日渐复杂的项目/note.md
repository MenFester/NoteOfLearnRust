# 学习笔记

## 概述

* 编写较为复杂的项目时，合理地对代码进行组织与管理很重要，因为我们不太可能记住代码中所有细枝末节
* 只有按照不同的特性来组织或分割相关功能的代码，我们才能够清晰地找到实现指定功能的代码片段，或确定哪些地方需要修改
* 一个包（package）可以拥有多个二进制单元包及一个可选的库单元包。随着包内代码规模的增长，可以将部分代码拆分到独立的单元包（crate）中，并将它作为外部依赖进行引用
* 对于那些特别巨大的、拥有多个相互关联的包的项目，Cargo提供了另一种解决方案：工作空间（workspace）
* 除了对功能进行分组，对实现的细节进行封装可以使你在更高的层次上复用代码。我们编写代码的方式决定了哪些部分会作为公共接口供他人使用，而哪些部分又会作为私有的细节实现
* 作用域（scope）：与组织和封装密切相关的概念
* Rust提供了一系列的功能来帮助我们管理代码，这些功能有时被统称为模块系统（module system），包括：
  * 包（package）：一个用于构建、测试并分享单元包的Cargo功能
  * 单元包（crate）：一个用于生成库或可执行文件的树形模块结构
  * 模块（module）及use关键字：它们被用于控制文件结构、作用域及路径的私有性
  * 路径（path）：一种用于命名条目的方法，这些条目包括结构体、函数和模块等

## 包与单元包

* 单元包可以被用于生成二进制程序或库。Rust编译时所用的入口文件称作这个单元包的根节点，它同时也是单元包的根模块
* 包由一个或多个提供相关功能的单元包集成而成，它所附带的配置文件Cargo.toml描述了如何构建这些单元包的信息
* 几条规则决定了包可以包含哪些东西：
  * 一个包中只能拥有最多一个库单元包
  * 包可以拥有任意多个二进制单元包
  * 包内必须存在至少一个单元包（库单元包或二进制单元包）
* Cargo会默认将src/main.rs视作一个二进制单元包的根节点而无须指定。这个二进制单元包与包拥有相同的名称
* Cargo会自动将src/lib.rs视作与包同名的库单元包的根节点。
* Cargo会在构建库和二进制程序时将这些单元包的根节点文件作为参数传递给rustc
* 我们可以在src/bin下添加源文件来创建出更多的二进制单元包，这个路径下的每个源文件都会被视作单独的二进制单元包
* 单元包可以将相关的功能分组（例如rand包），并放到同一作用域下。将单元包的功能保留在它们自己的作用域中，有助于指明某个特定功能来源于哪个单元包，并避免可能的命名冲突
* src/main.rs和src/lib.rs被称作单元包的根节点，因为这两个文件的内容各自组成了一个名为crate的模块，并位于单元包模块结构的根部

## 通过定义模块来控制作用域及私有性

* 模块允许我们将单元包内的代码按照可读性与易用性来进行分组
* 还允许我们控制条目的私有性。模块决定了一个条目是否可以被外部代码使用（公共），或者仅仅只是一个内部的实现细节而不对外暴露（私有）
* 使用` $ cargo new --lib xxxx `来创建一个名为xxxx的库
* 以mod关键字开头来定义一个模块，接着指明这个模块的名称
* 模块内可以包含结构体、枚举、常量、trait、函数等
* 当模块A被包含在模块B内时，我们将模块A称作模块B的子节点（child），并将模块B称作模块A的父节点（parent）
* 整个模块树都被放在命名crate的隐式根模块下

## 用于在模块树中指明条目的路径

* 为了在Rust的模块树中找到某个条目，我们同样需要使用路径。路径有两种形式：
  * 使用单元包名或字面量crate从根节点开始的绝对路径
  * 使用self、super或内部标识符从当前模块开始的相对路径
  * 绝对路径与相对路径都由至少一个标识符组成，标识符之间使用双冒号（::）分隔
* 模块不仅仅被用于组织代码，同时还定义Rust的私有边界（privacy boundary）：外部代码无法知晓、调用或依赖那些由私有边界封装了的实现细节。因此，你想要讲一个条目（比如函数或结构体）声明为私有时，可以将它防止到某个模块中
* Rust中所有条目（函数、方法、结构体、枚举、模块及常量）默认都是私有的。处于父级模块中的条目无法使用子级模块中的私有条目，但子级模块中的条目可以使用它所有祖先模块中的条目
* 使用pub关键字来暴露路径，属于同级节点的，无须pub也能互相访问
* 使用super关键字开始构造相对路径：从父模块开始构造相对路径
* 将结构体或枚举声明为公共的：
  * 当我们在结构体定义前使用pub时，结构体本身就称为了公共结构体，但它的字段依旧保持了私有状态。我们可以逐一决定是否将某个字段公开
  * 当我们将一个枚举声明为公共的时（enum关键字前放置pub），它所有的变体都自动变为了公共状态
  * 枚举只有在所有变体都公共时才能实现最大的功效，而必须为所有枚举变体添加pub则显得烦琐，因此所有的枚举变体默认都是公共的
  * 对于结构体而言，即便部分字段是私有的也不会影响到它自身的使用，所以结构体字段遵循了默认的私有性规则，除非被标记为pub，否则默认是私有的

## 用use关键字将路径导入作用域

* 可以借助use关键字来将路径引入作用域，并像使用本地条目一样来调用路径中的条目
* ` use crate::front_of_house::hosting `，使得hosting成为了该作用域下的一个有效名称，就如同hosting模块定义在根节点下
* 使用use将路径引入作用域时也需要遵守私有性规则
* 使用use来指定相对路径有些不同：必须在传递给use的路径的开始处使用关键字self，而不是从当前作用域中可用的名称开始
* 使用use将函数的父模块引入作用域意味着，我们必须在调用函数时指定这个父模块，从而更清晰地表明当前函数没有被定义在当前作用域中
* 当使用use将结构体、枚举和其他条目引入作用域时，我们习惯于通过指定完整路径的方式引入（即使用时不需要指定父模块）。如果有同名的条目，则必须指定父模块
* 使用as关键字来提供新的名称
* 当我们使用use关键字将名称引入作用域时，这个名称会以私有的方式在新的作用域中生效。为了让外部代码能够访问到这些名称，我们可以通过组合使用pub与use实现，这项技术也被称作重导出（re-exporting)（pub use 使一个名称可以在新作用域中被其他任意代码使用）
* 使用外部包：首先将它们列入Cargo.toml文件，接着使用use来将特定条目引入作用域
* 标准库（std）同样被视作当前项目的外部包。标准库已经被内置到了Rust语言中，所以不需要特意修改Cargo.toml来包含std
* 使用嵌套的路径来清理众多use语句：` use std::{cmp::Ordering, io}; `，` use std::io::{self, Write}; `(将std::io与std::io::Write引入作用域)
* 假如你想要将所有定义在某个路径中的公共条目都导入作用域，那么可以在指定路径时在后面使用` * `通配符：` use std::collections::*; `。应小心谨慎地使用这一特性

## 将模块拆分为不同的文件

* 在模块名称后使用分号而不是代码块，例如：` mod front_of_house; `，会让Rust前往与当前模块同名的文件加载模块内容
* 用文件夹区分父模块、子模块层级时，还是要弄清楚上一级模块有无一个文件夹（包括隐式的crate文件夹），子模块的文件必然放在父模块同名的文件夹中
* 举例：在lib.rs中声明了front_of_house模块，这个模块应该是crate的子模块，因此在隐式的crate文件夹中应该有一个front_of_house.rs文件；在front_of_house.rs文件中声明了hosting模块，这个模块应该是front_of_house模块的子模块，因此在显示的crate/front_of_house文件夹中应该有一个hosting.rs文件
