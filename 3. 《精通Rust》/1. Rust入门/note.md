# 学习笔记

## 前言

* 对于一种可能会改变你思考和推理代码的方式的语言，学习之初就需付出更多努力，并且认识到这一点非常重要

## 1.1 Rust是什么，以及为何需要关注它

* Rust是一种采用过去的知识解决将来的问题的技术
* Rust是一种快速、高并发、安全且具有授权性的编程语言
* Rust的运行时非常小，不需要垃圾收集，并且对于程序中声明的任何值，默认情况下更倾向于栈（stack）分配，而不是堆（heap）分配（开销）
* 虽然Rust是一种通用的多范式语言，但它的目标是C和C++占主导地位的系统编程领域（操作系统、游戏引擎、性能关键型应用）
* Rust还具有足够的表现力，你可以使用它构建高性能的Web应用程序、网络服务，类型安全的数据库对象关系映射（Object Relational Mapping，ORM）库，还可以将程序编译成WebAssembly在浏览器上运行
* Rust还在为嵌入平台构建安全性优先的实时应用程序方面获得了相当大的关注
* Rust作为一门静态和强类型语言而存在。静态属性意味着编译器在编译时具有所有相关变量和类型的信息，并且在编译时会进行大量检查，在运行时只保留少量的类型检查。强类型属性意味着不允许发生诸如类型之间自动转换的事情。强类型属性使Rust可以安全地重构代码，并在编译时捕获大多数错误，而不是在运行时出错
* Rust编写的程序表现力和性能都非常好，因为使用它你可以拥有高级函数式语言的大部分特性
* Rust很多设计决策中强调首要理念是编译期内存安全、零成本抽象和支持高并发
  * 编译期内存安全：Rust编译期可以在编译时跟踪程序中资源的变量。资源可以是内存地址，包含某个值的变量、共享内存引用、文件句柄、网络套接字或数据库连接句柄等。Rust中的引用类型（类型名称前面带有&标记的类型）与生命周期标记隐式关联（'foo），有时由程序员显示声明。在生命周期中，编译器可以跟踪代码中可以安全使用的位置。Rust通过这些引用上的生命周期标签来运行借用/引用检查算法，以确保你永远不能访问已释放的内存地址
  * 零成本抽象：编程的目的就是管理复杂性，这是通过良好的抽象来实现的。抽象让我们能够编写高级并且易于阅读的和推断的代码
  * 支持高并发：Rust是并发安全的，该语言具有应用程序接口（Application Programming Interface，API）和抽象能力，使得编写正确和安全的并发代码变得非常容易。Rust将数据包装成Mutex类型，以确保来自多个线程的数据进行同步可变访问。Rust采用了保护共享数据自身，而不是代码的概念。另一个新颖的想法是标记特征的概念，它在编译期验证，并确保在并发代码中同步和安全地访问数据。类型会被称为Send和Sync的标记特征进行注释标记，以指示它们是否可以安全地发送到线程或者在线程之间共享。当程序向线程发送值时，编译器会检查该值是否实现了所需的标记特征，如果没有，则禁止使用该值。当前CPU没有获得更多的时钟频率；相反，添加了更多内核。因此，并发编程是正确的发展方向。Rust使得编写并发代码变得轻而易举，并且降低了编写安全的并发代码的门槛。
* Rust还借鉴了C++的RAII原则用于资源初始化，这种技术的本质是将资源的生命周期和对象的生命周期绑定，而堆分配类型的解除分配是通过执行drop特征上的drop()方法实现的。当变量超出作用域时，程序会自动调用此方法。
* Rust还用Result和Option类型替代了空指针的概念，这意味着Rust不允许代码中出现null/undefinded的值，除非通过外部函数接口与其他语言交互，以及使用不安全代码时
* Rust语言还强调组合，而不是继承，并且有一套特征系统，它由数据类型实现

## 1.2 安装Rust工具链

* Rust工具链包含两个主要组件：编译器rustc和软件包管理器Cargo，后者有助于管理Rust项目。工具链发布有3个渠道：
  * 夜间版（Nightly）：主开发分支每天成功构建的程序，不是很稳定
  * 测试版（Beta）：该版本每6周发布一次，仅包含已经稳定的功能
  * 稳定版（Stable）：该版本每6周发布一次，测试分支会演变成新的稳定版本
* rustup是一款在所兼容的平台上安装Rust编译器的工具
  * 安装工具链的推荐做法是：` curl https://sh.rustup.rs -sSf | sh `
  * 将工具链更新到最新版本：` rustup update `
  * rustup更新自身的版本：` rustup self update `
  * 查看默认配置：` rustup show `
  * 告知rustup针对特定目录切换到夜间版本的工具链：` rustup override set nightly `，相应文件夹及其子目录的rustc、cargo等命令版本会自动切换到夜间版本
  * 如果由于某种原因想使用较旧版本的工具链或者对工具链进行降级，可以通过运行 ` rustup install nightly-2016-06-03 ` 命令，然后使用override子命令来达到目的

## 1.3 Rust简介

* 在较高层面，Rust程序会被组织成模块的形式，根模块会包含一个main()函数。
  * 对于二进制可执行项目，根模块通常是一个main.rs文件
  * 而对于程序库，根模块通常是一个lib.rs文件
* print!宏：
  * 对于"{}"格式化声明符，它会调用一个来自Display特征的方法
  * 对于"{:?}"格式化声明符，它会调用一个来自Debug特征的方法
  * 在开发过程中，通常需要输出数据类型以进行调试。使用"{:?}"格式化声明符时，上述方法在类型上是不可用的，我们需要在类型上添加`#[derive(Debug)]`属性来获取这些方法
* Rust中内置基元类型有
  * bool：布尔值，可以是true、false
  * char：字符
  * 整型（integer），支持最大长度128位
    * 有符号：i8，i16，i32，i64，i128
    * 无符号：u8，u16，u32，u64，u128
  * isize：指针大小的有符号整型。相当于32位CPU上的i32和64位CPU上的i64
  * usize：指针大小的无符号整型。相当于32位CPU上的u32和64位CPU上的u64
  * f32：32位浮点型
  * f64：64位浮点型
  * [T; N]：固定大小的数组，T表示数据类型，N表示元素数目
  * [T]：动态大小的连续序列的视图，T表示任意类型
  * str：字符串切片，主要用作引用，即&str。在 Rust 中有两种常用的字符串类型：str 和 String。str 是 Rust 核心语言类型，就是本章一直在讲的字符串切片（String Slice），常常以引用的形式出现（&str）。凡是用双引号包括的字符串常量整体的类型性质都是 &str。String 类型是 Rust 标准公共库提供的一种数据类型，它的功能更完善——它支持字符串的追加、清空等实用的操作。String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性。String 和 str 都支持切片，切片的结果是 &str 类型的数据。注意：切片结果必须是引用类型
  * (T, U, ..)：有限序列，T、U可以是不同类型
  * fn(i32) -> i32：一个接收i32类型参数并返回i32类型参数的函数
* 变量：
  * 关键字let声明变量。let语句不仅是为变量分配值，也是Rust中的模式匹配语句
  * Rust默认情况下变量不可变——在初始化变量后，你无法为变量分配其他值；如果需要将变量指向其他变量（同一类型），则需要在其前面加上关键字mut
* 函数基本上是返回值的表达式，默认情况下是()（Unit类型的值）
* 闭包：
  * 与函数类似，但具有声明它们的环境或作用域的更多信息。虽然函数具有与之关联的名称，闭包的定义没有（匿名函数），但可以将它们分配给变量。
  * Rust类型推断的另一个优点是，在大多数情况下，你可以为没有类型的闭包指定参数。定义一个什么都不做的无参数闭包：` let my_closure = ||() `
  * 和函数类似，闭包也可以存储在变量中，稍后调用或传递给其他函数
  * 闭包的主体可以是单一表达式，也可以是有花括号标识的多个表达式组成
  * 闭包主要用作高阶函数的参数。高阶函数时一个以另一个函数或闭包作为参数的函数
  * 闭包提供简便、抽象的另一个场景是，当你有一个对Vec等集合进行操作的函数时，希望根据某些条件过滤元素
* 字符串：
  * 在Rust中，字符串通常以两种形式出现：&str类型和String类型
  * Rust字符串保证是有效的UTF-8编码字节序列
  * String类型数据时在堆上分配的
  * &str类型数据通常是指向现有字符串的指针，这些字符串可以在栈和堆上，也可以是已编译对象代码的数据中的字符串
  * &是一个运算符，用于创建指向任何类型的指针
* 条件和判断
  * Rust中，if构造不是语句，而是一个表达式。语句不返回任何值，但表达式会返回值
    * 这意味着Rust中的if else条件总会返回一个值，该值可以是empty类型的()，也可能是实际值
    * 要注意，if和else分支应该具有相同的返回类型
    * 通过在一些代码中的if代码块中的字符串之后添加分号，编译器会认为用户希望抛弃该值
  * 对于更复杂的多值条件判断，Rust提供了被称为match表达式的强大构造来处理
    * match关键字后面跟着的是要检查的变量，后面跟一对花括号。在花括号内，编写表达式——匹配臂
    * 匹配臂表示匹配的变量可以采用的侯选值。每个匹配臂是通过可能写入变量的值来构造的，随后跟着是一个"=>"，然后右边是表达式
    * 可以在花括号中使用单行表达式或多行表达式。单行表达式需要用逗号进行分隔。多行表达式用花括号，后可以跟逗号，也可以不用
    * 每个匹配臂必须返回相同的类型
    * Rust允许我们通过使用catch all变量（other）或者下划线（_）来忽略其余的可能性
* 循环，通常都包含关键字continue和break
  * loop：表示无限循环
  * while
  * for：Rust中的for循环只适用于可以转换为迭代器的类型
  * Rust中执行循环的一个额外特性是能够使用名称标记循环代码块。这可以在你有两个或多个嵌套循环，并想要从它们中的任何一个中断的情况下使用，而不仅针对直接包含break语句的循环。Rust的标记都是 ` 'label ` 样式
* 自定义数据类型，是由用户定义的类型，它们可以是基元类型的包装器，也可以是多个自定义类型的组合，遵循驼峰命名法，有3种形式
  * 结构体（struct）
    * 单元结构体（unit struct）：
      * 关键字struct进行声明，随后是名称，并用分号作为结尾：` struct Dummy `
      * 单元结构体运行时不占用任何空间，因为没有与之关联的数据
      * 用到单元结构体的情况非常少
        * 可用于对没有与之关联的数据或状态进行实体建模
        * 可用于表示错误类型（结构体本身足以表示错误，而不需要对其进行描述）
        * 可用于表示状态机实现过程中的状态
    * 元组结构体（tuple struct）：
      * 具有相关联数据，其中的每个字段都没有命名，而是根据它们在定义中的位置进行引用
      * 元组结构体中的字段可以通过 ` variable.<index> ` 语法访问，索引以0开头
      * 访问元组结构体中字段的另一种方法是使用let语句对结构体进行解构
      * 对于5个以下的属性进行数据建模时，元组结构体是理想的选择
    * 类C语言的结构体，也是最常用的形式
      * 3个以上字段的数据类型，建议使用类C语言的结构体
      * 关键字struct进行声明，随后定义结构体的名称，结构体以花括号开头，并且声明了字段名称
      * 字段写成以逗号分隔的 `field: type` 对
      * 使用与字段具有相同名称的变量初始化字段时，可以使用字段初始化简化特性
      * 使用 ` struct.field_name ` 语法访问实例中的字段
      * 在结构体上使用mut，意味着所有字段都是可修改的
      * 使用类C结构体而不是元组结构体的有点在于，可以按任意顺序初始化字段
  * 枚举（enum）
    * 需要为不同类型的东西建模时，枚举可能是一种好办法
    * 使用关键字enum声明，之后跟枚举名称和一对花括号，在花括号内部可以编写所有可能的类型（即变体）
    * 变体可以在包含数据或不包含数据的情况下定义，并且包含的数据可以是任何基元类型、结构体、元组结构体、甚至是枚举
    * 在递归的情况下：例如有一个枚举Foo和一个引用枚举的变体，则该变体需要在指针类型（Box、Rc等）的后面，避免类型无限递归定义
    * 枚举名和变体用双冒号分隔
    * 不能使用未初始化的枚举，它必须是变体之一
    * 给定枚举值，要查看枚举实例，使用match表达式进行模式匹配
    * 在枚举上匹配时，可以使用解构语法
    * 枚举也广泛用于状态机，当其与match表达式搭配使用时，它们可使状态转换代码非常简洁。它们还可以用于自定义错误类型的建模。当枚举变体没有任何与之关联的数据时，它们可以像C语言的枚举那样使用，其中变体默认具有以0开头的整数值（isize），但也可手动标记整数值。这在与外部C程序库交互时很有用
  * 从函数式程序员的角度看，结构体和枚举也称为代数数据类型（Algebraic Data Type，ADT），因为可以使用代数规则来表示他们能够表达的值的取值区间
    * 枚举被称为求和类型，因为它可以容纳的值的范围基本上是其变体取值范围的总和
    * 结构体被称为乘积类型，因为它的取值区间是其每个字段取值区间的笛卡尔积
  * 联合（union），类似于C语言的联合，主要用于与C语言代码库交互
* 类型上的函数和方法
  * 通过impl块来实现
  * 结构体上的impl块
    * 关联方法：
      * 该方法没有self类型作为第1个参数
      * 类似于面向对象语言中的静态方法。这些方法在类型自身上即可调用，并且不需要类型的实例来调用
      * 通过在方法名称前加上结构体名称和双冒号来调用关联方法
    * 实例方法：
      * 将self作为第1个参数的函数。self指向实现该方法的实例
      * `instance.foo()`是一种语法糖，还可以这样调用：`Struct::foo(&instance)`
      * self作为第一个参数：方法将不允许你后续使用该实例。调用者将所有权移动到方法，方法返回后将不能使用实例
      * &self作为第一个参数：提供对实例的读取访问权限。表示self在方法续存期间被借用
      * &mut self：对实例的可变访问
  * 枚举上的impl块
* module、import和use语句
  * 模块是Rust程序中命名和组织代码的一种方式，Rust提供了多种创建模块的方法
  * Rust模块的主要内容：
    * 每个Rust程序都需要一个root模块
      * 对于可执行文件，它通常是main.rs文件
      * 对于程序库，它通常是lib.rs文件
    * 模块可以在其他模块内部声明，也可以组织为文件和目录
    * 需要使用关键字mod声明
    * 在root模块中，要在模块名称前使用关键字use，表示将元素引入作用域
    * 模块中定义的元素默认是私有的，需要使用关键字pub将它暴露给调用方
* 集合
  * 通常情况下，你的程序必须处理多个数据实例，因此可使用集合类型
  * Rust提供了多种内置类型来存储数据集合
    * 数组：
      * 具有固定长度
      * 存储相同类型元素
      * 用 `[T, N]` 表示，T代表任意类型，N代表数组元素的数量
      * 数组的大小不能用变量表示，并且必须是usize的字面值
    * 元组
      * 元组中的元素可以具有不同的类型，元组是异构集合，可用于将不同类型的元素存储在一起
      * 从函数返回多个值时可以使用它
    * 切片
      * 切片是获取集合类型视图的常用做法
      * 大多数用例是对集合类型中特定区间的元素进行只读访问
      * 切片基本上是指针或引用，指向现有集合类型中某个其他变量所拥有的连续区间
      * 切片是指向栈或堆中某处现有数据的胖指针，这意味着它还包含关于指向多少元素的信息以及指向数据的指针
      * 用 `&[T]`表示切片，T表示任意类型
      * 使用到&，是因为切片是不定长类型（unsized types），不能将切片存储为裸值——即仅在指针后面（理解为，切片是指向底层数据的一种结构，是一种引用，不是独立存在的）
      * &str类型也属于切片类型（[u8]），与其他字节切片的唯一区别在于，它们保证为UTF-8
      * 也可以在String或Vec上执行切片
    * 标准库中动态集合类型
    * 最常用类型：列表（vector）和键/值对（map）
      * 列表：
        * 和数组类似，不过他们的内容和长度不需要事先指定，并且可以按需增长
        * 它们时在堆上分配的
        * 使用构造函数 `Vec::new `，也可以使用宏 `vec![]`创建
      * 键/值对：
        * 来自std::collections模块，名为HashMap
        * 使用构造函数 `HashMap::new` 创建
        * 使用insert方法向其中新增、修改元素
        * 使用for循环遍历健/值对，for循环返回一个包含两个字段的元组(k, v)
        * keys()方法迭代访问键
        * values()方法迭代访问值
* 迭代器
  * 迭代器是一种构造，它提供了一种高效访问集合类型元素的方法
  * 迭代器的一个优点是它们提供了对集合中元素的更高级别抽象，而不是使用手动循环，因为后者很容易因为某个错误而终止执行
  * 迭代器的另一个优点是不会在内存中读取整个集合，并且是惰性的。惰性代表迭代器仅在需要时对集合中的元素进行求值或访问
  * 迭代器还可以与多个转换操作链接
  * 当你需要访问这些元素时，迭代器会提供next()方法，该方法尝试从集合中读取下一个元素
  * Rust中，迭代器是实现了Iterator特征的任意类型，可以在for循环中使用迭代器来遍历其元素。它们是大多数标准库集合类型实现的
  * Rust中处理集合类型时，经常会用到迭代器
  * 通过iter()或者into_iter()方法将大多数集合类型转换为迭代器