# 学习笔记

## 7.1 简介

* 模式解构“Pattern Destructure”是Rust中一个重要且实用设计。Destructure意思是把原来的结构肢解为单独的、局部的、原始的部分
* ` let (head, center, tail) = tuple `赋值号左边的内容就是“模式”，赋值号右边的内容就是需要被“解构”的内容
* Rust中模式解构原则是：构造和解构遵循类似的语法
* Rust的“模式解构”功能不仅出现let语句中，还可以出现在match、if-let、while-let、函数调用、闭包调用等情景中
* match具有功能最强大的模式匹配

## 7.2 match

* 当一个类型有多种取值可能性的时候，特别适合使用match表达式
* Rust要求match需要对所有情况做完整的、无遗漏的匹配。exhaustive意思就是遗漏的、穷尽的、彻底的、全面的，exhaustive是Rust模式匹配的重要特点
* 不想把每种情况一一列出，可以用一个下划线来表达“除了列出来的那些之外的其他情况”。相当于default
* 上游库作者可以用` [non_exhaustive] `的attribute标记一个enum或者struct，这样另一项目中使用这个类型的时候，无论如何都没办法在match表达式中通过列举所有的成员实现完整匹配，必须使用下划线才能完成编译（相当于为了兼容性强制要求下游使用默认分支，上游改动便不会引起下游编译报错）
* 下划线还能用在模式匹配的各种地方，用来表示一个占位符
* 下划线更像一个“关键字”。编译器不会把单独的下划线当成一个正常的变量名处理，如果把下划线后面跟上字母、数字、或者下划线就可以成为一个正常的标识符（比如：两个下划线是合法标识符）
* 如果变量x是非Copy类型，` let _ = x; `的意思是“忽略绑定”，此时会直接调用x的析构函数
* ` let _y = x; `的意思是“所有权转移”，_y在后面可以继续使用
* 除了了下划线，两个点..也可以在模式中作为“占位符”使用。下划线表示省略一个元素，两个点表示省略多个元素(含一个，中间的一部分等情况)
* 跟Rust中其他流程控制语法一样，match语法结构也同样可以是表达式的一部分。match表达式的每个分支可以是表达式，它们要么用大括号包起来，要么用逗号分开，每个表达式都必须具备同样的类型
* match除了匹配“结构”（模式）还能匹配“值”
* match可以用或运算符“|”来匹配多个条件
* match可以用范围作匹配条件，使用..、..=符号（参考第六章的区间表达方式） 
* 可以使用if作为“匹配看守”（match guards），当模式匹配成功且符合if条件，才执行后面的语句
* 在对变量的“值”进行匹配的时候，编译器依然会保证“完整无遗漏”检查，但是这个检查功能目前不是很完美，某些情况下会误报错误（通过默认分支的方法解决）
* 编译器会保证match的所有分支合起来一定覆盖了目标的所有可能取值范围，但是并不会保证各个分支是否会有重叠的情况。如果不同分支覆盖范围出现了重叠，总会执行第一条匹配成功的分支并忽略其他分支
* match的分支中可以使用`@`符号绑定变量，`@`符号前面是新声明的变量，后面是需要匹配的模式
* 如果在使用`@`的同时使用`|`，需要保证在每个条件上都绑定这个变量名字
* 当一个Pattern嵌套层次比较多的时候，如果我们需要匹配更深层次作为条件，又希望绑定上一层的数据，就要用`@`语法
* 因为模式匹配的时候有可能发生变量的所有权转移，使用ref就是为了避免出现所有权转移。ref是“模式”的一部分，它只能出现在赋值号左边。而&符号是借用运算符，是表达式的一部分，它只能出现在赋值号右边
* `let ref x = 5_i32;`变量x的类型是`&i32`
* `let ref x = &5_i32;`变量想绑定的类型是`&&i32`
* mut关键字和ref一样，是“模式”的一部分。使用了mut修饰的变量绑定，可以重新绑定到其他同类型的变量
* “重新绑定”和“变量遮蔽”是完全不同的作用机制。“重新绑定”要求变量本身有mut修饰，并且不能改变这个变量的类型；“变量遮蔽”要求必须重新声明一个新的变量，这个新变量与老变量之间的类型可以毫无关系
* mut关键字不仅可以在模式用于修饰变量绑定，还能修饰指针（引用）。`let mut x: &mut i32;`：第一个mut代表变量x本身可变，它能够重新绑定到另外一个变量上；第二个mut代表这个指针对于所指向的内存具有修改能力（可以用`*x = 1`），改变它所指向的内存的值 

## 7.3 if-let和while-let

* if-let ：` if let PATTERN = EXPRESSION { BODY }`，后面还可以跟一个可选的else分支
* while-let与if-let一样，提供了在while语句中使用“模式解构”的能力
* if-let和while-let还支持模式的“或”操作

## 7.4 函数和闭包参数做模式解构

* 一个函数接受一个结构体参数，可以直接在参数这里做模式解构
