# 学习笔记

## 6.1 数组

* 数组是一个容器，在一块连续内存中存储了一系列同样类型的数据
* 数组中元素的占用空间大小必须是编译期确定，数组所容纳的元素个数也必须是编译期确定且执行阶段不可变
* 如果需要使用变长的容器，可以使用标准库中的Vec/LinkedList等
* 数组类型的表示方式` [T; n] `，T代表元素类型，n代表元素个数（必须是编译期常量）。只有元素类型和元素个数完全相同，两个数组才是同类型的
* 数组与指针之间不能隐式转换
* 把数组作为参数传递给函数，这个数组不会退化成为一个指针，而是会完整复制进函数（函数体内对这个数组的改动不会影响到外面的数组）
* 数组元素访问使用中括号索引语法
* 可以直接在for...in循环中使用数组切片，而不能直接使用数组本身（数组本身没有实现IntoIterator trait，数组切片实现了）
* 多维数组：既然` [T; n] `是合法类型，那么元素T当然可以是数组类型，因此` [[T; m]; n] `也是合法类型
* 数组切片：
  * 数组切片对数组没有所有权，可以把数组切片看做专门指向数组的指针，是对数组的另一个“视图”
  * 数组` [T; n] `的借用指针的类型是` &[T; n] `，它通过编译器内部魔法转换为数组切片类型` &[T] `
  * 数组切片实质上还是指针，它不过是在类型系统中丢弃了编译阶段定长数组类型的长度信息，而将此长度信息存储为运行期的值
  * 数组切片是一个指向数组的指针，而它不止包含有一个指向数组的指针，切片本身还含带长度信息
* Slice与普通的指针不同，它有一个形象的名字：胖指针（fat pointer）
  * 与胖指针相对应的概念是“动态大小类型”（Dynamic Sized Type，DST），指编译期无法确定占用空间大小的类型
  * 由于不定长数组类型` [T] `在编译阶段无法判断该类型占用空间的大小，所以不能在栈上声明一个不定长数组的变量实例，也不能作为函数的参数、返回值。但指向不定长数组的胖指针的大小是确定的，` &[T] `可以用作变量实例、函数参数、返回值
  * DST可以当做合法类型看待，比如：实现trait、添加方法、用在泛型参数中
  * 胖指针设计避免了数组类型作为参数传递时自动退化为裸指针类型而丢失长度信息的问题，保证了类型安全
  * 这一设计仍然保持了与“所有权”、“生命周期”等概念相容的特点
* 对于DST类型，Rust有如下限制：
  * 只能通过指针来间接创建和操作DST类型
  * 局部变量和函数参数的类型不能是DST类型（`[T]`是DST类型，`&[T]`是胖指针）
  * enum中不能包含DST类型
  * struct中只有最后一个元素可以是DST类型
* Rust中的Range代表一个区间，通过两个小数点语法支持：
  * begin..end：` [begin, end) `。实际生成：std::ops::Range<_>类型的变量，这个类型实现了Iterator trait，因此可以直接应用到循环语句中
  * start..：` [start, +∞) `。实际生成：std::ops::RangeFrom类型的变量，只有起始没有结束的范围
  * ..end：`(-∞, end) `。实际生成：std::ops::RangeTo类型变量，代表没有起始只有结束范围
  * ..：` (-∞, +∞) `。实际生成：std::ops::RangeFull，代表没有上下限范围
  * Rust中还提供了左闭、右闭的语法：..=
    * start..=end：` [start, end] `，实际生成：std::ops::RangeInclusive类型的变量
    * ..=end：` (-∞, end] `，实际生成：std::ops::RangeToInclusive类型的变量
* 如果希望某个类可以执行“索引”读操作，就需要该类型实现std::ops::Index trait
* 如果希望某个类可以执行“索引”写操作，就需要该类型实现std::ops::IndexMut trait
* 为了防止索引操作导致程序崩溃，如果我们不确定使用的“索引”是否合法，应该使用get()方法调用来获取数组中的元素，它返回的类型是`Option<T>`
* 一般情况下，Rust不鼓励大量使用“索引”操作。正常的“索引”操作都会执行一次“边界检查”。在Rust中更地道的做法是尽量使用“迭代器”方法（如果我们同时需要index和内部元素的值，调用enumerate()方法）
* Iterator有很多有用的方法，合理地组合使用它们，能使程序表达能力强、可读性好、高效安全，可以满足我们绝大多数的需求

## 6.2 字符串

* Rust的字符串涉及两种类型：一种是&str，另外一种是String
* str是Rust的内置类型。&str是对str的借用。
* Rust字符串内部默认是使用utf-8编码格式（变长编码），而内置的char类型是4字节长度，所以Rust里面的字符串不能视为char类型的数组
* str是DST类型，&str是字符串切片类型（也是一个胖指针）
* 跟C/C++不同（字符串以'\0'结尾），Rust的字符串可以中间包含'\0'字符
* String和&str类型的主要区别是它有管理内存空间的权力。String类型在堆上动态申请了一块内存空间，它有权对这块内存空间进行扩容，内部实现类似于`std::Vec<u8>`类型。
* String实现了`Deref<Target=str> `的trait，所以在很多情况下，&String类型可以被编译器自动转换为&str类型（例如函数传参时的自动转换，形式参数声明为&str有更好的适应性）。&String类型自动转换为&str类型后，有权修改所指向内容，但无权给字符串扩容或释放内存
